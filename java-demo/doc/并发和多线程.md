# 并发与多线程


## 1 常见概念

### 1.1 操作系统线程运行状态

        
        NEW
        RUNNABLE
        RUNNING
        BLOCKED

### 1.2 Java虚拟机线程实际运行状态
         public enum State {
                NEW
                    尚未开始的线程处于此状态，即刚创建线程对象，未调用start()方法
      
                RUNNABLE
                    新建线程调用start()方法后，在Java虚拟机中执行的线程处于此状态，但它可能正在等待来自操作系统的其他资源（如处理器）。
                          
                BLOCKED
                    处于阻塞状态的线程正在等待监视器锁定进入同步块或同步方法，或者重入锁进入同步块或同步方法
                 后调用Object.wait()方法
  
                WAITING
                     由于调用以下方法之一，线程处于等待状态
                        Object.wait(); 无超时
                        Thread.join(); 无超时
                        LockSupport.park();
                     例如，a.在对象上调用Object.wait（）的线程正在等待另一个线程调用Object.notify（）或Object.notifyAll（）在该对象。
                          b.一个名为Thread.join（的线程正在等待指定的线程终止。
                              
                TIMED_WAITING
                      由于调用一个线程，线程处于定时等待状态,使线程处于定时等待状态可调用方法如下：
                         Thread.sleep(long);
                         Object.wait(long)
                         Thread.join(long);
                         LockSupport.parkNanos(long);
                         LockSupport.parkUntil(long);

                TERMINATED
                    终止线程的线程状态。 即线程已完成当前任务的执行。
         }
### 1.3 重入锁

#### 概念：
        一个线程试图获得它自己持有的锁，那么这个请求就会成功
#### 实现原理：
       1.为每个锁绑定所有者和计数值,每重入一次该计数值自增1，而当线程每退出一次计数值递减，直到计数值为零才释放锁。
#### 常用实现
       
        
### 1.4 sychroinzed
####     概述：
    在JDK1.6之前被称为重量级锁，然后在JDK1.6中为了减少获得和释放锁所带来的性能消耗引入了偏量锁和轻量级锁
      
####      实现原理：
        JVM规范中都是给予进入和对出Monitor对象来实现方法同步和代码块同步的，但两者的实现细节不同:
        代码块同步是使用monitorenter和monitorexit指令实现的
####      使用形式：
#####     普通方法+syncronized
   锁是当前实例对象
            
```java  

    public  class InstanceObjectSyncronizedTest{
         private Integer  num = 5;
           
          public syncronized Integer getNum(){
                num++
                return num;
          }
    }
    
```    




#####            静态方法+syncronized
锁是当前类的Class对象

```java

    public  class InstanceObjectSyncronizedTest{
          private static Integer  num = 5;
          
          public static synchronized  void IntegergetNum() {
                  ++num; 
          }
    }
    
    
```






#####     方法块+syncronized(Object.Class)
   锁是当前类的Class对象
```java




```
            
#####     方法块+syncronized
   锁是syncronized括号里配置的对象
```java



```    
 ### 1.5 lock接口及实现
 
 ### 1.6 volatile
    volatile是轻量级的sncronized的实现，只修饰变量，多线程访问不会发生阻塞，但volatile不具备原子性，功能使变量在多线程间可见。
   * 使用方式：
    
          1）确保自身状态的可见性
          2）确保他们所引用的对象的可见性
   * 应用场景：
   
          1）标记循环控制状态，检查状态来判断是否退出循环
          2）单线程写,多线程读
 
 ## 2 线程安全模型
 
### 2.1 COW（copy on  write）
      来源于linux的fork命令，java中的实现类CopyOnWriteArrayList 读操作无需加锁，可能会出现脏数据，遍历时被其他线程修改不会出现并发修改异常（CurrentModificationException）
### 2.2 CAS(compare and swap) 
      即比较与替换被封装为原子操做，ConcurrentHashMap和HashMap都采用数组+链表+红黑数的结构存储数据
### 2.3 RWS(read write separate) 
      即读写分离，LinkedBlockingQueue，用两个可重入锁枷锁head和last

 
 ## 3 应用场景
 
 ### 3.1 多读少写
 
 ### 3.2 多写少读
 
 ## 4 线程安全的类的设计
  
 ### 4.1 判断类是否是线程安全的
 
 * 找出构成对象状态的所有变量
 * 找出约束状态变量的不变性条件
 * 建立对象状态的并发访问管理策略
     
 
 
